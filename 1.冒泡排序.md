## 冒泡排序  
## 冒泡算法  
冒泡排序的英文Bubble Sort，是一种最基础的交换排序。  
大家一定都喝过汽水，汽水中常常有许多小小的气泡，哗啦哗啦飘到上面来。这是因为组成小气泡的二氧化碳比水要轻，所以小气泡可以一点一点向上浮动。而我们的冒泡排序之所以叫做冒泡排序，正是因为这种排序算法的每一个元素都可以像小气泡一样，根据自身大小，一点一点向着数组的一侧移动。 
## 具体示例  
#### 冒泡排序第一版：  
有8个数组成一个无序数列：5，8，6，3，9，2，1，7，希望从小到大排序。  
按照冒泡排序的思想，我们要把相邻的元素两两比较，根据大小来交换元素的位置，过程如下：  
第一轮：  
首先让5和8比较，发现5比8要小，因此元素位置不变。  
接下来让8和6比较，发现8比6要大，所以8和6交换位置。   
继续让8和3比较，发现8比3要大，所以8和3交换位置。  
继续让8和9比较，发现8比9要小，所以元素位置不变 。  
接下来让9和2比较，发现9比2要大，所以9和2交换位置。   
接下来让9和1比较，发现9比1要大，所以9和1交换位置。  
最后让9和7比较，发现9比7要大，所以9和7交换位置。  
这样一来，元素9作为数列的最大元素，就像是汽水里的小气泡一样漂啊漂，漂到了最右侧。   
这时候，我们的冒泡排序的第一轮结束了。数列最右侧的元素9可以认为是一个有序区域，有序区域目前只有一个元素。得到5,6,3,8,2,1,7,9序列  
第二轮：  
先让5和6比较，发现5比6要小，因此元素位置不变。  
接下来让6和3比较，发现6比3要大，所以6和3交换位置。  
继续让6和8比较，发现6比8要小，因此元素位置不变。  
接下来让8和2比较，发现8比2要大，所以8和2交换位置。  
接下来让8和1比较，发现8比1要大，所以8和1交换位置。  
继续让8和7比较，发现8比7要大，所以8和7交换位置。 得到序列5,3,6,2,1,7,8,9  
......  
经过8轮得到目标序列  
到此为止，所有元素都是有序的了，这就是冒泡排序的整体思路。原始的冒泡排序是稳定排序。由于该排序算法的每一轮要遍历所有元素，轮转的次数和元素数量相当，所以时间复杂度是O（N^2） 。  
#### 第一版代码实现：
代码非常简单，使用双循环来进行排序。外部循环控制所有的回合，内部循环代表每一轮的冒泡处理，先进行元素比较，再进行元素交换。
```Java
    private static void maopaosort(int array[]){
    	int tmp=0;
    	for(int i=0;i<array.length;i++){
    		for(int j=0;j<array.length-i-1;j++){
    			if(array[j]>array[j+1]){
    				tmp=array[j];
    				array[j]=array[j+1];
    				array[j+1]=tmp;
    			}
    		}
    	}
	}
	public static void main(String[] args) {
       int [] array  =new int []{5,8,6,3,5,4,1,9};
       maopaosort(array);
       System.out.println(Arrays.toString(array));
	}
```  
  
#### 冒泡排序第二版：
让我们回顾一下刚才描述的排序细节，仍然以5，8，6，3，9，2，1，7这个数列为例，当排序算法分别执行到第六、第七、第八轮的时候，这种情况下，如果我们能判断出数列已经有序，并且做出标记，剩下的几轮排序就可以不必执行，提早结束工作。  
#### 第二版代码实现：
这一版代码做了小小的改动，利用布尔变量isSorted作为标记。如果在本轮排序中，元素有交换，则说明数列无序；如果没有元素交换，说明数列已然有序，直接跳出大循环。  
```Java
private static void maopaosort(int array[]){
    	int tmp=0;
    	for(int i=0;i<array.length;i++){
			boolean isSort=true;
    		for(int j=0;j<array.length-i-1;j++){
    			if(array[j]>array[j+1]){
    				tmp=array[j];
    				array[j]=array[j+1];
    				array[j+1]=tmp;
					isSort=false;
    			}
    		}
			if(isSort){
    			break;
    		}
    	}
    }
	public static void main(String[] args) {
       int [] array  =new int []{5,8,6,3,5,4,1,9};
       maopaosort(array);
       System.out.println(Arrays.toString(array));
	}
```  
  
#### 冒泡排序第三版：
为了说明问题，咱们这次找一个新的数列：3,4,2,1,5,6,7,8 这个数列的特点是前半部分（3，4，2，1）无序，后半部分（5，6，7，8）升序，并且后半部分的元素已经是数列最大值。让我们按照冒泡排序的思路来进行排序，看一看具体效果：  
第一轮  
元素3和4比较，发现3小于4，所以位置不变。  
元素4和2比较，发现4大于2，所以4和2交换。  
元素4和1比较，发现4大于1，所以4和1交换。  
元素4和5比较，发现4小于5，所以位置不变。  
元素5和6比较，发现5小于6，所以位置不变。  
元素6和7比较，发现6小于7，所以位置不变。  
元素7和8比较，发现7小于8，所以位置不变。  
第一轮结束，数列有序区包含一个元素：3,2,1,4,5,6,7,8中的8  
第二轮  
元素3和2比较，发现3大于2，所以3和2交换。  
元素3和1比较，发现3大于1，所以3和1交换。  
元素3和4比较，发现3小于4，所以位置不变。  
元素4和5比较，发现4小于5，所以位置不变。  
元素5和6比较，发现5小于6，所以位置不变。  
元素6和7比较，发现6小于7，所以位置不变。  
元素7和8比较，发现7小于8，所以位置不变。  
第二轮结束，数列有序区包含一个元素：2,1,3,4,5,6,7,8中的7,8  
这个问题的关键点在哪里呢？关键在于对数列有序区的界定。  
按照现有的逻辑，有序区的长度和排序的轮数是相等的。比如第一轮排序过后的有序区长度是1，第二轮排序过后的有序区长度是2 ......实际上，数列真正的有序区可能会大于这个长度，比如例子中仅仅第二轮，后面5个元素实际都已经属于有序区。因此后面的许多次元素比较是没有意义的。如何避免这种情况呢？我们可以在每一轮排序的最后，记录下最后一次元素交换的位置，那个位置也就是无序数列的边界，再往后就是有序区了。  
 #### 第三版代码实现：
这一版代码做了小小的改动，利用布尔变量isSorted作为标记。如果在本轮排序中，元素有交换，则说明数列无序；如果没有元素交换，说明数列已然有序，直接跳出大循环。这一版代码中，sortBorder就是无序数列的边界。每一轮排序过程中，sortBorder之后的元素就完全不需要比较了，肯定是有序的。  
```Java
private static void maopaosort(int array[]){
    	int tmp=0;
		int lastExchangeIndex=0;//记录最后一次交换的位置
    	int sortBorder=array.length-1;//无序数列的边界，每次比较只需要比到这里为止
    	for(int i=0;i<array.length;i++){
			boolean isSort=true; //有序标记，每一轮的初始是true
    		for(int j=0;j<sortBorder;j++){
    			if(array[j]>array[j+1]){
    				tmp=array[j];
    				array[j]=array[j+1];
    				array[j+1]=tmp;
					isSort=false;//有元素交换，所以不是有序，标记变为false
    				lastExchangeIndex=j;//把无序数列的边界更新为最后一次交换元素的位置
    			}
    		}
			sortBorder=lastExchangeIndex;
			if(isSort){
    			break;
    		}
    	}
    }
	public static void main(String[] args) {
			int [] array  =new int []{3,4,2,1,5,6,7,8,9};
			maopaosort(array);
			System.out.println(Arrays.toString(array));
	}
```  
  
